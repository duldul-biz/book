
# AR

## 0、为什么转
1、我对这个方面感兴趣 想做应用开发  游戏项目更换的有些快  游戏引擎的变换也比较快 android framework 或者 微视用到的技术
2、这里存在一定的表现的问题，同时工作室特殊要求 保密项目未上线前答辩会有所限制 我答辩了两次 第一次是在NPEngine转Unity的时候 所以Unity比较浅 第二次是在Unity转Unreal的时候 unity沉淀的到了源码层面  答辩的技巧有所欠缺 我说的是资源管理从工程到源码  但是没有整体做内存分析 评委的评语是从源码层优化了资源引用计数 但是没有对内存做整体分析。

## 1、类型
基于陀螺仪的 基于罗盘的 大多数设备支持
基于ArEngine 华为提供 需要特定设备
基于Arkit 苹果提供 iphone6s 以上  ios11
基于ArCore google 部分手机支持
ArUnit 商汤 


## 2、
 1、AR大致流程
 对于当前ARFrame 这一帧的中心发出射线 返回平面碰撞的hitRet
 从碰撞点中选点 合法  低于相机0.1米  相机位置在（0,0,0）  碰撞距离要在Min0.1米 Max2米之间比较合适
 选完点之后这个点的平面就是放置妖精的平面 也是放置妖精的点

 选完点之后有个Update去获取相机的position 和 角度 然后不断的更新场景相机的位置
 另外也会不断的Update去获取相机的投影矩阵 去不断更新场景相机的投影矩阵

2、VR陀螺仪流程
开始初始化的时候把相机角度置为原点，然后把妖精放在中间，陀螺仪可以计算相机的旋转角度从而同步到场景相机中 然后这样旋转手机相机 场景相机也在旋转


3、VR罗盘流程

4、相机镜头优化
 WebCamTexture  帧率和清晰度不可兼得  不够清晰
方案选择：用一个原生UI绘制相机 Unity在场景下设置为透明  相机纹理绘制到FrameBuffer 然后Unity绘制FrameBuffer


## 3、渲染流水线
总体流程是：应用阶段  几何阶段  光栅化阶段
### 3.1 应用阶段：准备好场景数据 相机位置 粗粒度剔除 最终输出渲染图元
把数据加载到显存 
设置渲染状态 用哪个顶点着色器 哪个片元着色器 材质
调用Drawcall

### 3.2 几何阶段：逐顶点操作  还有是顶点坐标变换空间  最终输出屏幕空间的二维坐标
顶点数据  顶点着色器  曲面细分着色器  几何着色器 裁剪  屏幕映射 
- 顶点着色器 顶点着色 空间变换  布料 水面 
- 几何着色器 
- 裁剪 
- 屏幕映射 


### 3.3 光栅化阶段：产生像素
三角形设置 三角形遍历 片元着色器 逐片元操作 像素
- 三角形设置 这个阶段会计算光栅化一个三角网格所需要的信息
- 三角形遍历 检查每个像素是否被一个三角形网格覆盖 生成片元 每个像素做插值 可能还有纹理坐标插值 法线插值
- 片元着色器 纹理采样技术
- 逐片元操作 也叫输出合并  深度测试 模板测试 颜色合并 颜色混合
片元  模板测试 深度测试 混合 颜色缓冲区
模板测试 可以做渲染阴影 轮廓渲染


### 3.4 像素处理阶段：

### 3.5 HLSL CG GLSL
Unreal HLSL DX
GLSL OpenGL
CG Nvidia  真正的跨平台
IL


### 3.6 坐标系变换
模型空间 
世界空间
观察空间 摄像机空间
投影 观察变换
裁剪空间

### 3.7 Unity渲染流水线


LWRP
HDRP
1、检查场景中的物体是否要渲染 剔除
2、收集并排序所有要渲染的物体相关信息并整理为dc 一个dc包括了网格 渲染数据 纹理信息 材质信息 合并dc
3、创建batch
3.1 修改渲染状态 setpass call
3.2 发送dc 根据pass call
3.3 如果房钱是个dc GPU渲染mesh  这里会告知顶点着色器 和 片元着色器
4 Unity 渲染线程
4.1 mainthread
4.2 render thread
4.3 worker thread
渲染顺序 camera depth
透明和不透明
sortinglayer
orderinlayer
renderqueue


- SRP
- LWRP
- HDRP


### 3.8 BRDF
自发光 + 高光反射 + 漫反射 + 环境光
Cm + Cspec + Cdiffucse + Ca 
环境光：直接等于一个值
自发光：自发光直接使用
漫反射：Clight*Mdiffuse


C(spec)=C(light) * m(spec) * max(0,r*v)
r = 2()

C(spec)=C(light) * m(spec) * max(0,n*h)


## 4、效果实现
### 4.1轮廓
绘制一遍物体 然后写入模板1
第二遍绘制放大绘制 然后模板测试 关闭深度测试 深度写入
如果是要被遮挡的才显示 那个开启深度测试 但是是深度Greater的才写入

### 4.2描边 同轮廓问题
还可以用深度差值
还可以用法线点乘算cos


### 

## 5、性能
避免Alpha Blend穿透问题




## 6、算法
### 6.1凸包算法
Graham扫描算法
1、找左下角的点
2、极角排序
3、依次扫描 sin值小于0继续 大于0 回退把点移除栈 







1、计算机及相关专业本科及以上学历； 2、有三年以上3D开发经验，熟悉常见3D引擎架构设计，在渲染、动画、物理、AI、性能调优等其中某一领域有丰富经验。熟练掌握C++，具备移动平台(iOS/Android)开发经验； 3、熟悉设计模式，数据结构和算法，了解3D图形学和有相关开发经验者优先； 4、良好的逻辑思维和编程习惯，具备独立解决技术问题的能力； 5、学习能力强，有责任感，有良好的沟通能力，具备团队合作精神，能承受一定的工作压力
